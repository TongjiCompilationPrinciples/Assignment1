	左递归文法：
<程序>→<程序首部> <分程序>
<程序首部>→PROGRAM <标识符>
<分程序>→[<常量说明>][<变量说明>]<语句>（注：[ ]中的项表示可选）
<常量说明>→CONST <常量定义>{，<常量定义>} ; （注： { }中的项表示可重复若干次）
<常量定义>→<标识符>:=<无符号整数>
<变量说明>→VAR<标识符>{，<标识符>};
<复合语句>→BEGIN <语句>{; <语句>} END
<语句>→<赋值语句> | <条件语句 >| <循环语句> | <复合语句> | <空语句>（这里的空语句应该是不报错）
<赋值语句>→<标识符>:=<表达式>
<加法运算符>→ + | -
<乘法运算符>→ * | /
<表达式>→[+|-]项 | <表达式> <加法运算符> <项>
<项>→<因子> | <项><乘法运算符> <因子>
<因子>→<标识符> |<无符号整数> | (<表达式>)
<条件语句>→IF <条件> THEN <语句>
<循环语句>→WHILE <条件> DO <语句>
<条件>→<表达式> <关系运算符> <表达式>

1.构造递归下降程序（控制语句/布尔表达式需要增加一些额外的程序/代码）

	目前问题：
递归下降进入其他“非终结符”子程序时候的FIRST判断？
递归下降何时报错还不太清楚，需要进一步搞懂
符号表目前还未搞懂，寻进一步弄懂
到底是如何生成中间代码的？？变量地址如何确定？

	两个表：符号表 + 中间代码表
每个非终结符的结果都会产生一个”中间变量“（无需优化）
条件语句直接生成goto，出递归后由上一层函数进行中间代码索引的记录和最终的回填
符号表查找（二分？也不用二分，因为定义只存在一开始，即顺序查找？）


这是原先的输出：
0: (BEC, 1, -, x)
1: (BEC, 2, -, y)
2: (JGE, x, 5, 6)
3: (ADD, x, 1, tmp0)
4: (BEC, tmp0, -, x)
5: (JUP, -, -, 2)
6: (JLE, y, 0, 9)
7: (SUB, y, 1, tmp1)
8: (BEC, tmp1, -, y)
9: (ADD, y, x, tmp2)
10: (BEC, tmp2, -, y)

x 1 2
y 1 3
tmp0 2 2
tmp1 2 1
tmp2 2 3